
// these objects are what you get after the program is parsed. 
// a program is stored as an array of lines
/*
programs have the form
	cmd[0] = command arg1 arg2 arg3
	...
	all of the args are ints; indices into stuff. 
	what the stuff is depends on context 
	
	all prBase are created in the objs[] of the page 
	in which the program is running



float = floating-point number
arg = localVarName or inputVarName
res = arg


program = (commandLine)+
commandLine = 
	input inputVarName type? 
	given float float
	localVarName line arg arg
	localVarName circle arg arg
	localVarName param arg arg
	localVarName first arg arg
	localVarName second arg arg
	localVarName closest arg arg
	addOut localVar
	
	
	
input is always an associative array. 
the "inputVar"


calling a program

the only way to run a machine is 
a) call prPage.load(filename) 
	this loads a file and creates one or more machines, 
	which are stored in an array
	
b) call prPage.run(machineName, arguments), which returns "outputs", 
	an array of integers indexed by output variable names.
	The "outputs" could just be ignored; could be you just want to 
		thePage.objs[outputs[aName]] = an object generated by...

what about programs that generate marks? sheesh. 
*/


/// reserved words for machine commands
const PR_ERROR 		= 0; 	
const PR_GIVEN 		= 1; 
const PR_LINE 		= 2; 
const PR_CIRCLE 	= 3; 
const PR_PARA 		= 4; 
const PR_FIRST 		= 5; 
const PR_SECOND 	= 6; 
const PR_CLOSEST 	= 7; 
const PR_SEGMENT	= 8;
const PR_ARC		= 9;
const PR_PAUSE 		= 10; 	// purely for dramatic effect
const PR_GROUP 		= 11; 	// group assignment
const PR_OUTPUT		= 12; 	// label outputs
const PR_INPUT 		= 13; 	//  "    inputs
const PR_EOL 		= 14; 	// token to divide up commands
const PR_MACHINE 	= 15; 	// first line of machine; names machine
const PR_END 		= 16; 	// last line of machine
// goto? if? eek. 
const PR_CMD_COUNT 	= 17; 	// how many command are there? 




const char reservedWords = { 
	"error", 
	"given", "line", "circle", "param", "first", "second", "closest", 
	"segment", "arc", "pause", "group", 
	"input", "output", "EOL", "input", "machine", "end"
	};
	
	

class prCommand { 
	int cmd, arg1, arg2, res; 
}

// this is used by "run"
class prMachine {
	String name; 
	prCommand commands[]; 
	int commandCount; 
	
	int expectedInputs[]; 	// the strings associated in the input array
	int expInpCount; 			
	
	String outputNames[]; 	// the strings associated in the output array
	int outputIndices[]; 	
	int outputCount;
}


class prMachine.processInputs = function(inArray, machine) { 

prPage.prototype.run = function(input, machine) {
	for (i=0; i<numLocals; ++i) { 
		locals[i] = 0; 
	}
	
	for (i=0; i<machine.expInpCount; ++i) { 
		// converts inputs from numbers associated with strings to numbered locals. 
		locals[i] = input[machine.expectedInputs[i]]; 
	}
	
	for (i=0; i<machine.commandCount; ++i) { 
		switch (machine.commands[i].cmd) { 
			case PR_GIVEN: 
				xin = machine.commands[i].arg1; 
				yin = machine.commands[i].arg2; 
				locals[machine.commands[i].res] = this.addGiven(xin, yin); 
				break; 
			case PR_LINE: 
				o1 = machine.commands[i].arg1; 
				o2 = machine.commands[i].arg2; 
				locals[machine.commands[i].res] = this.addLine(o1, o2); 
		}		
	}
	
	outputs = new Array(); 
	for (i=0; i<machine.outputCount; ++i) { 
		outputs[machine.outputNames[i]] = outputIndices[i]; 
	}
}


// the parser is a singleton and exists only while the program is loaded. 
// its goal is to convert input program texts into a minimal list of commands and strings. 
prM prParser() {
	string uniqueNames[]; 
	int uniqueNameCount; 

		
	// returns the index of "aName" in the "uniqueNames" array. 
	// if aName was not in "uN", adds it, too. 
	// if aName is a number, convert it to that number and add that. 
	int storeUnique(char aName) {
		var i done, res;
		res = -1; 
		done = 0; 
		i=0; 
		while ((done==0)&&(i<uniqueNameCount)) { 
			if (aName==uniNames[i]) { 
				done = 1; 
				res = i; 
			}
			++i;
		}
		if (done==0) {
			uniNames[uniNameCount] = aName;
			res = uniNameCount; 
			++uniNameCount; 
		}
		return res; 
	}
	
	void makeMachine(string textin) {
		
		
			
	}
	
	void load(filename) { 
		
	
	
	}

	
}

